#+TITLE: REPL Codes
#+PROPERTY: header-args :tangle /dev/null

* Notebooks!

** ì•Œì§œë°°ê¸° states

#+begin_src tuareg
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
      let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
      G.serialize_to_bin result ~suffix:"df_edges" ;
      result
    | Some filename ->
      Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let renderer_finished = Main.build_graph renderer_graph

  let site_graph = List.nth_exn splitted 1
#+end_src

** Notebooks

*** WORKING Notebook89

ì œì¼ ì¤‘ìš”í•œ ê±° ë‘ ê°€ì§€ë¥¼ ë´…ì‹œë‹¤.

Controllerì˜ GetMapping/PostMapping annotationì´ ë‹¬ë¦° ë©”ì†Œë“œë“¤ì„ ì¼ë‹¨ ëª¨ì•„ë³´ìŸˆ.

**** renderer ì•ˆì— ìˆëŠ” annotation

#+begin_src tuareg
  let renderer_methods = G.all_methods_of_graph renderer_graph

  let renderer_udfs = List.filter ~f:Method.is_udf renderer_methods

  let renderer_udf_with_mapping = List.filter ~f:(fun udf ->
      let annots = Annotations.get_annots udf in
      List.exists ~f:(fun annot ->
          String.is_substring annot.name ~substring:"Mapping") annots
    ) renderer_udfs
#+end_src

ì°¾ì•˜ë‹¹:

#+begin_src tuareg
  let renderer_udf_with_mapping = ["ResourceSupport IndexController.index()";
                                   "Resources GuidesController.listGuides()";
                                   "ResponseEntity GuidesController.renderGuide(String,String)";
                                   "ResponseEntity GuidesController.showGuide(String,String)";
                                   "ResponseEntity MarkupController.renderMarkup(MediaType,String)"]
#+end_src

ì´ ì¤‘ í•˜ë‚˜ì— ëŒ€í•´ ë¬¼ì–´ë³´ë©´, ë‚˜ë¨¸ì§€ë¥¼ ì „ë¶€ ë¶„ë¥˜í•´ ë‚´ì•¼ í•œë‹¤. ğŸ¤”

ì´ê²Œ í˜„ì¬ ë˜ëŠ”ì§€ë¥¼ ë´…ì‹œë‹¹. ì–´ë–»ê²Œ ë³´ì§€?

1. ê°ê°ì— ëŒ€í•´ í…Œì¸íŠ¸ ë ˆì´ë¸”ì„ ê¸°ì–µí•´ ë‘ì.
2. í•˜ë‚˜ì— ëŒ€í•´ ë¬¼ì–´ë³´ì.
3. ê·¸ ë‹¤ìŒì— ì´ê²ƒë“¤ì˜ í…Œì¸íŠ¸ ë ˆì´ë¸”ë“¤ì´ ì „ë¶€ ì œëŒ€ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆëŠ”ì§€ ë³´ì.

***** í•˜ë‚˜ì— ëŒ€í•´ì„œ ë¬¼ì–´ë³´ëŠ” ë°©ë²•: Loop.loop

ê¸°ë³¸ì ìœ¼ë¡œ, REPL!

- question object ë§Œë“¤ê³ ,
- response object ë§Œë“¤ê³ .

ê·¸ëŸ¼ ë‚˜ë¨¸ì§€ëŠ” ì´ê²ƒë“¤ì„ dependencyë¡œ í•´ì„œ ê³„ì‚°ë  ê±°ì„. ë£°ë£¨ë„ë¼

#+begin_src tuareg
  let question = Question.AskingForLabel
      "Resources GuidesController.listGuides()"

  let response = Response.ForLabel ("Resources GuidesController.listGuides()", TaintLabel.Source)
#+end_src

ê·¸ë¦¬ê³  íŒŒë¼ë¯¸í„°ë„ ì…ë ¥ì‹œì¼œì¤ì‹œë‹¤.

#+begin_src tuareg
  let current_snapshot = renderer_finished

  let received_responses = []

  let nodewise_featuremap = NodeWiseFeatureMap.empty

  let count = 0
#+end_src

ì ë§Œ... ê·¼ë° axiomì€ ì–¸ì œ ì ìš©ë˜ì§€??
--> í¬í•œí•˜ê²Œë„, NS/CS edge ë§Œë“¤ì–´ì§€ê¸° ì „ì— ì ìš©ëœë‹¤. ê±±ì • ë…¸ë…¸

ì–´ì©„ë“  ìš”ë ‡ê²Œ ë§Œë“¤ê³ , ì½”ë“œë¥¼ ê°–ê³ ì˜¤ì.

#+begin_src tuareg
  (* sort applicable Propagation Rules by adequacy. *)
  let propagation_rules_to_apply =
    MetaRules.ForPropagation.sort_propagation_rules_by_priority current_snapshot response
      received_responses
  in
  let propagated =
    List.fold
      ~f:(fun acc prop_rule ->
          fst
          @@ propagator response acc None propagation_rules_to_apply received_responses []
            PropagationRules.all_rules )
      ~init:current_snapshot propagation_rules_to_apply
  in
  let propagated' = Axioms.apply_axioms propagated in
  G.snapshot_to_json propagated' ;
#+end_src

ì™¤ì¼€ ì˜¤ë˜ê±¸ë¦¬ì§€... ë§ì•„ì„œ ê·¸ëŸ°ê°€;; ë˜ê²Œ ë§ë„¤

**** WORKING ì´ê±°ì´ê±°

ê·œì¹™ ì¤‘ì— ~internal_nonbidirectional_library_node_is_a_src_if_leaf_is_sink~ ì´ê±°ê°€ ìˆëŠ”ë°, ì´ê±° ë•Œë¬¸ì— ~ZipFile.close()~ ê°€ sourceë¡œ ì˜ëª» ë¶„ë¥˜ë˜ê³  ìˆìŒ.

ì•„ ê·¼ë° ì´ê±° ì—„ì²­ ì˜¤ë˜ ê±¸ë¦¬ë„¤. ì›ë˜ ì´ë ‡ê²Œ ì˜¤ë˜ ê±¸ë ¸ë‚˜?

--> ì§€ê¸ˆ ë³´ë©´, nodewise Similarityê°€ ë„ˆë¬´ ë§ì€ë°??

#+begin_src tuareg :tangle no
  current_visiting_vertices: [("ResponseEntity GuidesController.showGuide(String,String)", "{ line 79 }"); ("ResponseEntity GuidesController.showGuide(String,String)", "{ line 75 }"); ("ResponseEntity GuidesController.showGuide(String,String)", "{ line 74 }"); ("ResponseEntity GuidesController.showGuide(String,String)", "{ line 73 }"); ("ResponseEntity GuidesController.showGuide(String,String)", "{ line 70 }"); ("ResponseEntity GuidesController.showGuide(String,String)", "{ line 69 }"); ("ResponseEntity GuidesController.showGuide(String,String)", "{ line 68 }"); ]
#+end_src

ì¤‘ê°„ì— ìˆëŠ” ê±°ê¹Œì§€ ìƒê¸°ë„¤.

****** WORKING ê°œì„ ë°©ì•ˆ

ìš°ë¦¬ê°€ ê²°êµ­ í•˜ê³  ì‹¶ì€ ë§ì€:

"GetMappingì„ ë‹¬ê³  ìˆëŠ” udf fê°€ rootì™€ leafë¥¼ ëª¨ë‘ ì°¨ì§€í•˜ê³  ìˆê³ , ê°ê° source, sinkì´ë‹¤. ê·¸ëŸ¼ GetMappingì„ ë‹¬ê³  ìˆê³ , rootì™€ leafë¥¼ ëª¨ë‘ ì°¨ì§€í•˜ê³  ìˆëŠ” ë‹¤ë¥¸ udfë“¤ ì—­ì‹œ sourceì™€ sinkì´ë‹¤."

ê·¸ë¦¬ê³  "ê°ê° source, sinkì´ë‹¤." ë¼ëŠ” ì‚¬ì‹¤ì— ì´ë¥´ê²Œ ëœ ê²ƒì€: "GetMappingì„ ë‹¬ê³  ìˆëŠ” udf fê°€ rootì™€ leafë¥¼ ëª¨ë‘ ì°¨ì§€í•˜ê³  ìˆë‹¤ë©´, ë‘˜ ë‹¤ sourceì´ê³  sinkì¸ì§€ ë¬¼ì–´ë´ë¼" ë¼ëŠ” askingruleì´ í•„ìš”í•˜ë‹¤.

--> ì´ê±° ê°€ì§€ê³  ì—°ì‚°ëŸ‰ì„ ì¤„ì¼ ìˆ˜ ì—†ì„ê¹Œ???
--> ê¸€ì„. ì˜ ëª¨ë¥´ê² ë‹¤.

ì•„ ì´ê±° ê·¼ë° ì–´ë””ì„œ ì´ë ‡ê²Œ ë©ˆì¹«ë©ˆì¹«í•˜ëŠ” ê±°ì§€? ~nodewise_similarity_propagation_rule chosen~ ì—¬ê¸°ì„œ ìê¾¸ ë©ˆì¶”ëŠ”ë°.

ê·¼ë° í•œ ê°€ì§€ ì§šì´ëŠ” ê±´... historyê°€ ì—…ë°ì´íŠ¸ë˜ê³  ìˆì§€ ì•Šë‹¤ëŠ” ê²ƒì´ë‹¤. ê·¸ë˜ì„œ ë¬´í•œì¬ê·€ ë„ëŠ” ê²ƒê°™ì´ ë³´ì„. ì´ ê°€ì„¤ì´ ë§ëŠ”ì§€ ë³´ê¸° ìœ„í•´ í•œë²ˆ Loop.propagatorë¥¼ ë´ì•¼ê² ìŒ. *ë¬¼ë¡  REPLì—ì„œ*.

#+begin_src tuareg
  let question = Question.AskingForLabel "ResponseEntity GuidesController.showGuide(String,String)"

  let response = Response.ForLabel ("ResponseEntity GuidesController.showGuide(String,String)", TaintLabel.Source)

  let question = Question.AskingForLabel
      "Resources GuidesController.listGuides()"

  let response = Response.ForLabel ("Resources
  GuidesController.listGuides()", TaintLabel.Source)

  let current_snapshot = renderer_finished

  (* Loop.propagator íŒŒë¼ë¯¸í„°ë“¤ *)

  let new_fact = response

  let current_snapshot = (* acc *) current_snapshot

  let previous_snapshot = None

  let rules_to_propagate = [{RulesOfInference.PropagationRules.rule= RulesOfInference.PropagationRules.nodewise_similarity_propagation_rule; label= "nodewise_similarity_propagation_rule"}]

  let prev_facts = received_responses

  let history = []

  let prop_rule_pool = PropagationRules.all_rules
#+end_src

ì…ë ¥ ì™„ë£Œ.

ì•Œê²Œ ëœ ì‚¬ì‹¤:

- [X] ì‚¬ì‹¤ historyëŠ” ì—…ë°ì´íŠ¸ë˜ê³  ìˆì—ˆë‹¤: current_visiting_vertices @ history.
- [X] ê·¸ëŸ¼ termination conditionì´ ì´ìƒí•˜ë‹¤ëŠ” ê²ƒ. ğŸ¤”

--> ê·¸ë˜ì„œ termination condition ì•½ê°„ ë°”ê¿”ë´„: Vertexê°€ historyì— ë“¤ì–´ìˆìœ¼ë©´ ëë‚´ëŠ” ê²Œ ì•„ë‹ˆë¼ Methodê°€ historyì— ë“¤ì–´ìˆìœ¼ë©´ ëë‚´ë„ë¡.

ì•„ë‹ˆ;;; ì´ì œëŠ” ë˜ ì™œ reproduceê°€ ì•ˆë˜ëƒ ëŒ€ì²´ ì•„ì˜¤ì˜¤ì˜¤ì˜¤
--> reproduceí–ˆë‹¤. ì–´ë–»ê²Œ í–ˆëŠ”ì§€ëŠ” plans2.orgì— ì ì–´ë†¨ìŒ.

ì´ì œ ë‹¤ë¥¸ ë¡œê¹… ë¹¼ê³  *historyë§Œ* ì°ì–´ ë³´ì.

** WORKING Notebook90

NS ì—£ì§€ê°€ ê°¯ë§¤í•‘ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì‚¬ì´ì— ì–´ë–»ê²Œ ë˜ì–´ìˆëŠ”ì§€ ë³´ê³ ì‹¶ì€ë°

#+begin_src tuareg
  let renderer_udf_with_mapping = ["ResourceSupport IndexController.index()";
                                   "Resources GuidesController.listGuides()";
                                   "ResponseEntity GuidesController.renderGuide(String,String)";
                                   "ResponseEntity GuidesController.showGuide(String,String)";
                                   "ResponseEntity MarkupController.renderMarkup(MediaType,String)"]
#+end_src

ì¿¼ë¦¬ë¥¼ ì–´ë–»ê²Œ ë‚ ë ¤ì•¼ë˜ë‚˜

#+begin_src tuareg
  let all_ns_edges = G.get_edges renderer_finished
      ~label:EdgeLabel.NodeWiseSimilarity

  let edges_containing_mapping = List.filter ~f:(fun (v1, _, v2) ->
      List.mem renderer_udf_with_mapping (Vertex.get_method v1) ~equal:Method.equal && List.mem renderer_udf_with_mapping (Vertex.get_method v2) ~equal:Method.equal
    ) all_ns_edges
#+end_src

ì¿¼ë¦¬ë§Œ ê°€ì§€ê³ ì„  ì˜ ëª¨ë¥´ê² ë‹¤. í•œë²ˆ visualizeë¥¼ í•´ë³´ê³  ì‹¶ì€ë°.

# debugging is a very well defined problem. Enjoy!

**** DONE Visualizing
CLOSED: [2022-02-14 Mon 13:12]

#+begin_src tuareg
  let empty = G.empty

  let constructed =
    List.fold ~f:(fun acc edge ->
        G.add_edge_e acc edge
      ) ~init:empty edges_containing_mapping

  let _ = Visualizer.visualize_snapshot constructed ~autoopen:true ~micro:false
#+end_src

ë‘ ê°€ì§€ ë¬¸ì œê°€ ìˆë‹¤:
- indexë‘ listGuidesê°€ NS í´ëŸ¬ìŠ¤í„°ì— ì—†ë‹¤.
  - compute_nodewise_similarity ìŠ¤í¬ë¦½íŠ¸ì—ì„œ í™•ì¸í•´ë³¼ ì¼ì´ë‹¤.
- NS ì—£ì§€ê°€ ë„ˆë¬´ë„ˆë¬´ ë§ë‹¤. ìŠ¤íŒ¨ë‹íŠ¸ë¦¬ë¡œ ë‹¤ì´ì–´íŠ¸ê°€ ì•ˆ ë˜ì–´ìˆë‹¤.
  - ì´ê±´ ì–´ëœ¨ì¼€ í•œë‹´ã„·ã„·
    - SpanningTree.mlì„ ë¶€í™œì‹œì¼œì•¼ê² ëŠ”ë°?? ìœ¼ìœ¼ìœ¼ ì—”ì§€ë‹ˆì–´ë§ ì‹œëŸ¬ã…“ã…“
    - ì–´ ë­ì•¼ ë‚˜ ì´ê±° ì•ˆì§€ì› ì—ˆë„¤ã…‹ã…‹ã…‹ã…‹

**** TODO indexë‘ listGuidesê°€ ì™œ NS í´ëŸ¬ìŠ¤í„°ì— ì—†ëŠ”ì§€?

**** DONE ìŠ¤íŒ¨ë‹íŠ¸ë¦¬ë¡œ ë‹¤ì´ì–´íŠ¸ ì‹œí‚¤ê¸°
CLOSED: [2022-02-14 Mon 18:17]

****** ìš”ê±¸ í•˜ë©´ ë­ê°€ ì¢‹ì€ë°??

- ì—°ì‚°ëŸ‰ì„ (ë§ì´) ì•„ë‚€ë‹¤. ì–¼ë§ˆë‚˜ ì•„ë¼ëŠ”ì§€ ì¢€ ë³¼ê¹Œ?

#+begin_src tuareg
  let constructed =
    List.fold ~f:(fun acc edge ->
        G.add_edge_e acc edge
      ) ~init:empty edges_containing_mapping

  let dieted = SpanningTree.prune_to_mst constructed

  let _ = List.length @@ G.all_edges_of_graph constructed
  (* 128 *)

  let _ = List.length @@ G.all_edges_of_graph dieted
  (* 30 *)
#+end_src

25í¼ë¡œ ë–¨ì–´ì§„ë‹¤!!

***** ì–´ë–»ê²Œ í•˜ëŠ”ë°?

#+begin_src tuareg
  let mst_edges = [
    ("ResponseEntity GuidesController.renderGuide(String,String)",
     "GuideContentResource GuideRenderer.render(GuideType,String)");
    ("ResponseEntity GuidesController.renderGuide(String,String)",
     "ResponseEntity GuidesController.showGuide(String,String)");
    ("ResponseEntity GuidesController.renderGuide(String,String)",
     "ResponseEntity MarkupController.renderMarkup(MediaType,String)" )
  ]

  let acc = ref G.empty

  let _ = List.iter ~f:(fun (m1, m2) ->
      let m1_vertices = G.this_method_vertices renderer_graph m1
      and m2_vertices = G.this_method_vertices renderer_graph m2 in
      List.iter ~f:(fun m1_vertex ->
          List.iter ~f:(fun m2_vertex ->
              acc := G.add_edge_e !acc (m1_vertex, EdgeLabel.NodeWiseSimilarity, m2_vertex) ;
              acc := G.add_edge_e !acc (m2_vertex, EdgeLabel.NodeWiseSimilarity, m1_vertex)
            ) m2_vertices
        ) m1_vertices
    ) mst_edges

  let result = !acc

  let _ = List.length @@ G.all_edges_of_graph result (* 528 *)

  let dieted = SpanningTree.prune_to_mst result

  let _ = List.length @@ G.all_edges_of_graph dieted (* 80 *)
#+end_src

ë² ë¦¬êµ¿!!! ì˜ˆìƒë³´ë‹¤ ë” ì¢‹ì•„ì¡Œë‹¤.

ì´ì œ ì´ê±¸ ê°€ì ¸ë‹¤ê°€ ì–´ë–»ê²Œ í•´ì•¼í•˜ë‚¨??

ì´ì œ SimilarityHandlerì—ë‹¤ê°€ ìš”ê±¸ ë¼ì›Œë„£ìœ¼ë©´ ëœë‹¤! ì•¼í˜¸!!
--> í•´ê²°!

** Notebook91

Controllerì˜ Mappingë“¤ë¼ë¦¬ CSì—£ì§€ê°€ ìƒê²¨ì•¼ í•˜ëŠ”ë°, ì§€ê¸ˆ ëª‡ ê°œê°€ ì—†ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•¨.

#+begin_src tuareg
  let all_cs_edges = G.get_edges renderer_finished
      ~label:EdgeLabel.ContextualSimilarity

  let edges_containing_mapping = List.filter ~f:(fun (v1, _, v2) ->
      List.mem renderer_udf_with_mapping (Vertex.get_method v1) ~equal:Method.equal && List.mem renderer_udf_with_mapping (Vertex.get_method v2) ~equal:Method.equal
    ) all_cs_edges
#+end_src

--> ì–´ì´ì¿  ì—„ì²­ ì—†ë„¤. ë””ë²„ê¹…í•´ì•¼ì§€ ë­.

**** @GetMapping ë”±ì§€ ë¶™ì€ íŠ¸ë í¬ë“¤ ëª¨ìœ¼ê¸°

@GetMapping ë”±ì§€ê°€ ë¶™ì–´ì„œ ê³ ë†ˆì—ì„œ ì‹œì‘í•´ ê³ ë†ˆìœ¼ë¡œ ëë‚˜ëŠ” íŠ¸ë í¬ë“¤ ëª¨ìœ¼ê¸°

#+begin_src tuareg
  let trunk_finder ~(start : G.LiteralVertex.t) ~(end_ : G.LiteralVertex.t) (graph : G.t) : trunk list
    =
    let all_trunks = identify_trunks graph in
    List.filter
      ~f:(fun trunk ->
          Vertex.equal (G.LiteralVertex.to_vertex start graph.graph) (List.hd_exn trunk)
          && Vertex.equal (G.LiteralVertex.to_vertex end_ graph.graph) (List.last_exn trunk) )
      all_trunks
#+end_src


#+begin_src tuareg
  let index = "ResourceSupport IndexController.index()"

  let listGuides = "Resources GuidesController.listGuides()"

  let renderGuide = "ResponseEntity GuidesController.renderGuide(String,String)"

  let showGuide = "ResponseEntity GuidesController.showGuide(String,String)"

  let renderMarkup = "ResponseEntity MarkupController.renderMarkup(MediaType,String)"

  let renderer_udf_with_mapping = [index; listGuides; renderGuide; showGuide; renderMarkup]
#+end_src

ìš”ê²ƒë“¤ì— ëŒ€í•´ì„œ longest_trunkë¥¼ ì°¾ì•„ë´…ì‹œë‹¤.

#+begin_src tuareg
  open Trunk

  let _ = Visualizer.visualize_snapshot df_edges_added ~autoopen:true ~micro:false

  let index_longest_trunk =
    longest_trunk_finder ~start:index ~end_:index df_edges_added

  let listGuides_longest_trunk =
    longest_trunk_finder ~start:listGuides ~end_:listGuides df_edges_added

  let renderGuide_longest_trunk =
    longest_trunk_finder ~start:renderGuide ~end_:renderGuide df_edges_added

  let showGuide_longest_trunk =
    longest_trunk_finder ~start:showGuide ~end_:showGuide df_edges_added

  let renderMarkup_longest_trunk =
    longest_trunk_finder ~start:renderMarkup ~end_:renderMarkup df_edges_added
#+end_src

ì•„ ì´ê±° ì™œì¸ì§€ ì•Œê² ë‹¤.
(ArrayList.<init>(), { line 93 })
-> (List GithubClient.fetchOrgRepositories(String), { line 93 }) ->

ì´ëŸ° í”„ë¦¬í”½ìŠ¤ê°€ ìˆì–´ì„œ ê·¸ë ‡ë„¤.

--> ê·¸ë˜ë„ indexë¥¼ ë¬¼ì–´ë´¤ì„ ë•Œ ë‹¤ë¥¸ controllerë“¤ì´ ë§ˆí‚¹ë˜ê³  ìˆì§€ ì•Šì•„, ì—¬ì „íˆ ë” ë§ì€ inspectionì´ í•„ìš”í•˜ë‹¤.
*í•œ ê°€ì§€ í¬ë§ì´ ë³´ì´ëŠ” ê±´, ì–´ì œì™€ ê°™ì´ ì—„ì²­ë‚œ ì¬ê·€ì— ë¹ ì§€ì§€ëŠ” ì•ŠëŠ”ë‹¤ëŠ” ê²ƒ.*

trunkë¥¼ ë½‘ì„ ë•Œ ê·¸ëƒ¥ ìˆ˜ë™ìœ¼ë¡œ ë½‘ì•„ë„ ë  ê±° ê°™ì€ë°?? ë­í•˜ëŸ¬ êµ³ì´ í•¨ìˆ˜ë¥¼ ì§œë‚˜??

ì˜¤ì¼€ì´... ì ì  progressì— ë‹¤ê°€ê°€ëŠ” ê±° ê°™ì•„ ì¢‹ë‹¤.

toResourceë‘ renderê°€ ì§€ê¸ˆ sinkë¡œ ì˜¤ì¸ë˜ê³  ìˆë„¤. ë¶„ì„ê¸° ì•ˆ ê³ ì¹˜ê³ ë„ ì—¬ê¸°ì„œ í•´ê²°ë³¼ ìˆ˜ ìˆì„ ê±° ê°™ì€ë° (ê·¸ë¦¬ê³  ê·¸ê²Œ ëœ fragile; ì¦‰ robustí•œ ë°©ë²•ì´ê¸°ë„ í•˜ê³ ).
--> ì´ì–´ë¶™ì´ëŠ” ë°©ë²•ìœ¼ë¡œ.

** Notebook92

ë³¸ê²© ëŠê¸´ ë°ì´í„°í”Œë¡œ ì´ì–´ë¶™ì´ê¸°

íì•„ì•„ì•„ì•„

*** WORKING ì™œ render -> renderGuide ì—£ì§€ê°€ ì—†ì„ê¹Œ?

ìƒ˜í”Œ jsonì„ ë§Œë“¤ì.

#+begin_src json
  {
      "defining_method":
      "ResponseEntity GuidesController.renderGuide(String,String)",
      "access_path": "(guideContentResource, [])",
      "location": "{ line 88 }",
      "chain": [
          {
          "current_method":
          "ResponseEntity GuidesController.renderGuide(String,String)",
          "status": "Define",
          "access_path": "(guideContentResource, [])",
          "location": "{ line 88 }",
          "using":
          "GuideContentResource GuideRenderer.render(GuideType,String)"
      },
          {
          "current_method":
          "ResponseEntity GuidesController.renderGuide(String,String)",
          "status": "VoidCall",
          "callee": "void ResourceSupport.add(Link)",
          "location": "{ line 89 }",
          "with": "(param_add_89_0, [])"
      },
          {
          "current_method":
          "ResponseEntity GuidesController.renderGuide(String,String)",
          "status": "VoidCall",
          "callee": "void ResourceSupport.add(Link)",
          "location": "{ line 90 }",
          "with": "(param_add_90_0, [])"
      },
          {
          "current_method":
          "ResponseEntity GuidesController.renderGuide(String,String)",
          "status": "Call",
          "callee": "ResponseEntity ResponseEntity.ok(Object)",
          "location": "{ line 91 }",
          "with": "(param_ok_91_0, [])"
      },
          {
          "current_method":
          "ResponseEntity GuidesController.renderGuide(String,String)",
          "status": "Define",
          "access_path": "($irvar15, [])",
          "location": "{ line 91 }",
          "using": "ResponseEntity ResponseEntity.ok(Object)"
      },
          {
          "current_method":
          "GuideResource GuideResourceAssembler.toResource(Repository)",
          "status": "Define",
          "access_path": "($irvar13, [])",
          "location": "{ line 22 }",
          "using": "ResponseEntity GuidesController.renderGuide(String,String)"
      },
          {
          "current_method":
          "GuideResource GuideResourceAssembler.toResource(Repository)",
          "status": "Call",
          "callee":
          "ControllerLinkBuilder ControllerLinkBuilder.linkTo(Object)",
          "location": "{ line 21 }",
          "with": "(param_linkTo_21_0, [])"
      },
          {
          "current_method":
          "GuideResource GuideResourceAssembler.toResource(Repository)",
          "status": "Define",
          "access_path": "($irvar14, [])",
          "location": "{ line 21 }",
          "using": "ControllerLinkBuilder ControllerLinkBuilder.linkTo(Object)"
      },
          {
          "current_method":
          "GuideResource GuideResourceAssembler.toResource(Repository)",
          "status": "Call",
          "callee": "Link LinkBuilderSupport.withRel(String)",
          "location": "{ line 22 }",
          "with": "(param_withRel_22_0, [])"
      },
          {
          "current_method":
          "GuideResource GuideResourceAssembler.toResource(Repository)",
          "status": "Define",
          "access_path": "($irvar15, [])",
          "location": "{ line 22 }",
          "using": "Link LinkBuilderSupport.withRel(String)"
      },
          {
          "current_method":
          "GuideResource GuideResourceAssembler.toResource(Repository)",
          "status": "VoidCall",
          "callee": "void ResourceSupport.add(Link)",
          "location": "{ line 21 }",
          "with": "(param_add_21_1, [])"
      },
          {
          "current_method":
          "GuideResource GuideResourceAssembler.toResource(Repository)",
          "status": "Dead"
      }
      ]
  }
#+end_src

ìš”ê±°ë¥¼ test_json3.json ìœ¼ë¡œ ì €ì¥í•©ì‹œë‹¤

#+begin_src tuareg
  let mini_json =
    let in_channel = In_channel.create "test-chain3.json" in
    let out = Json.from_channel in_channel in
    In_channel.close in_channel ;
    out

  let mini_graph = G.empty |> batch_add_vertex mini_json |> batch_add_edge mini_json

  let _ = Visualizer.visualize_snapshot mini_graph ~micro:false ~autoopen:true
#+end_src

ã…‡0ã…‡ ì§„ì§œ ì•ˆ ë˜ê³  ìˆì—ˆë„¤

ì´ê±´ GraphMaker.EdgeMaker.edge_list_of_chain_slice_listì—ë‹¤ê°€ Define slice ì²˜ë¦¬í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ ì¶”ê°€í•˜ë©´ ëŒ.

**** WORKING ì´ì–´ë¶™ì´ëŠ” ë©”ì»¤ë‹ˆì¦˜ ë§Œë“¤ê¸°

#+begin_src json
  {
    "defining_method":
      "ResponseEntity GuidesController.renderGuide(String,String)",
    "access_path": "(guide, [])",
    "location": "{ line 83 }",
    "chain": [
      {
        "current_method":
          "ResponseEntity GuidesController.renderGuide(String,String)",
        "status": "Define",
        "access_path": "(guide, [])",
        "location": "{ line 83 }",
        "using": "ResponseEntity GuidesController.renderGuide(String,String)"
      },
      {
        "current_method":
          "ResponseEntity GuidesController.renderGuide(String,String)",
        "status": "Call",
        "callee":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "location": "{ line 40 }",
        "with": "(guideName, [])"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Call",
        "callee": "StringBuilder StringBuilder.append(String)",
        "location": "{ line 43 }",
        "with": "(param_append_43_1, [])"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Define",
        "access_path": "($irvar3, [])",
        "location": "{ line 43 }",
        "using": "StringBuilder StringBuilder.append(String)"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Call",
        "callee": "String StringBuilder.toString()",
        "location": "{ line 43 }",
        "with": "(param_toString_43_0, [])"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Define",
        "access_path": "(repositoryName, [])",
        "location": "{ line 43 }",
        "using": "String StringBuilder.toString()"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Call",
        "callee": "StringBuilder StringBuilder.append(String)",
        "location": "{ line 45 }",
        "with": "(param_append_45_1, [])"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Define",
        "access_path": "($irvar8, [])",
        "location": "{ line 45 }",
        "using": "StringBuilder StringBuilder.append(String)"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Call",
        "callee": "String StringBuilder.toString()",
        "location": "{ line 45 }",
        "with": "(param_toString_45_0, [])"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Define",
        "access_path": "(tempFilePrefix, [])",
        "location": "{ line 45 }",
        "using": "String StringBuilder.toString()"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Call",
        "callee": "File File.createTempFile(String,String)",
        "location": "{ line 52 }",
        "with": "(param_createTempFile_52_0, [])"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Define",
        "access_path": "(zipball, [])",
        "location": "{ line 52 }",
        "using": "File File.createTempFile(String,String)"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "VoidCall",
        "callee": "void File.deleteOnExit()",
        "location": "{ line 53 }",
        "with": "(param_deleteOnExit_53_0, [])"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Call",
        "callee": "boolean FileSystemUtils.deleteRecursively(File)",
        "location": "{ line 90 }",
        "with": "(param_deleteRecursively_90_0, [])"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Define",
        "access_path": "($irvar32, [])",
        "location": "{ line 90 }",
        "using": "boolean FileSystemUtils.deleteRecursively(File)"
      },
      {
        "current_method":
          "GuideContentResource GuideRenderer.render(GuideType,String)",
        "status": "Dead"
      }
    ]
  }
#+end_src

***** DONE [2] ì°¾ê¸°

#+begin_src tuareg
  let mini_json =
    let in_channel = In_channel.create "render-renderGuide.json" in
    let out = Json.from_channel in_channel in
    In_channel.close in_channel ;
    out

  let mini_graph = G.empty |> batch_add_vertex mini_json |> batch_add_edge mini_json

  let _ = Visualizer.visualize_snapshot renderer_graph ~autoopen:true ~micro:false
  let _ = Visualizer.visualize_snapshot mini_graph ~autoopen:true ~micro:false
#+end_src

#+begin_src tuareg
  let return_stmt_locs = Deserializer.deserialize_return_stmts ()

  let render = "GuideContentResource GuideRenderer.render(GuideType,String)"

  let render_return_locs = List.Assoc.find_exn return_stmt_locs ~equal:Method.equal render

  let render_vertices_with_return_locs =
    List.hd_exn @@ G.fold_vertex (fun vertex acc ->
        let methname = Vertex.get_method vertex
        and locset = Vertex.get_loc vertex in
        let match_ = Method.equal methname render &&
                     List.exists render_return_locs ~f:(fun loc ->
                         String.is_substring ~substring:(string_of_int loc) locset
                       ) in
        if match_ then vertex::acc else acc
      ) mini_graph []

  let find_vertices_with_return_locs (method_: Method.t) (graph: G.t) =
    List.hd_exn @@ G.fold_vertex (fun vertex acc ->
        let methname = Vertex.get_method vertex
        and locset = Vertex.get_loc vertex in
        let match_ = Method.equal methname render &&
                     List.exists render_return_locs ~f:(fun loc ->
                         String.is_substring ~substring:(string_of_int loc) locset
                       ) in
        if match_ then vertex::acc else acc
      ) mini_graph []
#+end_src

ì•„ ì˜¤ì¼€ì´. ë‚´ í¸ê²¬ì´ ìˆì—ˆìŒ. return lineì„ ë“¤ê³  ìˆëŠ” ë²„í…ìŠ¤ê°€ ë°˜ë“œì‹œ df_leafë¼ëŠ” ë³´ì¥ì´ ì—†ì§€.
--> +í•¨ìˆ˜ ì‘ì„± ì™„ë£Œ+.
--> í•¨ìˆ˜ë¡œ í¬ì¥í•˜ë©´ ë¨. ì´ê±° GraphReprì—ë‹¤ê°€ ê°–ë‹¤ë†“ì.
--> ì™„ë£Œ.

ì´ì œ ì´ì–´ë¶™ì¼ ê³³ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì„ ì°¾ìœ¼ë©´ ëœë‹¤.

***** DONE [3] ì°¾ê¸°
CLOSED: [2022-02-16 Wed 20:24]

renderì—ì„œ ì‹œì‘í•˜ëŠ” ë‹¤ë¥¸ ê·¸ë˜í”„ë¥¼ ì°¾ì•„ë‚´ë©´ ë˜ì§€. locsetì´ LocationSet.dummyì¸ ë²„í…ìŠ¤ì—ì„œ ì‹œì‘í•˜ëŠ” ê·¸ë˜í”„ë¥¼ ì°¾ì•„ë‚´ë©´ ë¨.

#+begin_src tuareg
  let find_another_ends (method_: Method.t) (graph: G.t) : G.V.t list =
    let collected = G.fold_vertex (fun vertex acc ->
        let methname = Vertex.get_method vertex
        and locset = Vertex.get_loc vertex in
        if Method.equal methname method_ &&
           LocationSet.equal locset LocationSet.dummy2 then
          vertex::acc else acc
      ) graph [] in
    collected

  let _ = find_another_ends render renderer_graph
#+end_src

***** DONE [1] ì°¾ê¸°
CLOSED: [2022-02-17 Thu 20:02]

#+begin_src tuareg
  let find_caller_locations (ending: Method.t) (graph: G.t) : G.V.t list =
    let ending_vertices =
      G.fold_vertex (fun vertex acc ->
          let method_ = Vertex.get_method vertex in
          if Method.equal method_ ending
          then vertex::acc
          else acc) graph []  in
    List.filter ending_vertices ~f:(fun vertex ->
        not @@ List.mem (get_recursive_preds graph (G.LiteralVertex.of_vertex vertex) ~label:EdgeLabel.DataFlow) vertex ~equal:Vertex.equal)
#+end_src

***** ë§ˆì¹¨ë‚´ ì´ì–´ë¶™ì´ê¸° í…ŒìŠ¤íŠ¸


#+begin_src tuareg
  module Json = Yojson.Basic

  let mini_json =
    let in_channel = In_channel.create "render-renderGuide.json" in
    let out = Json.from_channel in_channel in
    In_channel.close in_channel ;
    out

  let mini_graph = G.empty |> batch_add_vertex mini_json |> batch_add_edge mini_json

  open DataFlowEdges.Repair

  let healed = DataFlowEdges.Repair.reconnect_disconnected_edges renderer_graph

  let render = "GuideContentResource GuideRenderer.render(GuideType,String)"

  let method_ = render

  and graph = mini_graph

  let _ = Visualizer.visualize_snapshot renderer_graph ~autoopen:true ~micro:false

  let _ = Visualizer.visualize_snapshot healed ~autoopen:true ~micro:false

  let first = find_first render renderer_graph

  let second, third = find_second_and_third render renderer_graph

  let fourths = find_fourths render renderer_graph
#+end_src

#+begin_src tuareg
  let graph = renderer_graph

  let method_ = "ResourceSupport IndexController.index()"
    
  let method_ = "GuideContentResource GuideRenderer.render(GuideType,String)"
#+end_src
