(* behold the power of Emacs... *)

open GraphRepr
open ListMonad
open InfixOperators
open ContextualFeatures
open SimilarityHandler
open Loop
open RulesOfInference
open NodeWiseFeatures
open Yojson.Basic
open GraphMaker
open DirectoryManager
open Chain
open Method
open GraphSplitter
open Annotations
open Trunk
open SpawnPython
module Json = Yojson.Basic

exception End

type json = Json.t

let json = Deserializer.deserialize_json ()

let received_responses = []

let trunk_finder ~(start : G.LiteralVertex.t) ~(end_ : G.LiteralVertex.t) (graph : G.t) :
    trunk array =
  let all_trunks = identify_longest_trunks graph in
  Array.filter
    ~f:(fun trunk ->
      Vertex.equal (G.LiteralVertex.to_vertex start graph.graph) trunk.(0)
      && Vertex.equal (G.LiteralVertex.to_vertex end_ graph.graph) (Array.last trunk) )
    all_trunks


module Notebook56 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let all_vertices = G.all_vertices_of_graph df_edges_added

  (* ============ renderer ============ *)
  let renderer_graph = List.nth_exn splitted 0

  let renderer_vertices = G.all_vertices_of_graph renderer_graph

  let renderer_methods = G.all_methods_of_graph renderer_graph (* Without Test Codes *)

  (* 근데 일단 visualization부터 해 보자. *)

  let _ = Visualizer.visualize_snapshot renderer_graph ~micro:false ~autoopen:false

  let _ = Trunk.identify_longest_trunks renderer_graph

  (* it works *instantaneously* on renderer_graph!!!! *)

  (* ============ site ============ *)

  let site_graph = List.nth_exn splitted 1

  let site_vertices = G.all_vertices_of_graph site_graph

  let site_methods = G.all_methods_of_graph site_graph (* Without Test Codes *)

  let identify_trunks (graph : G.t) : t array =
    let df_only_graph = G.leave_only_df_edges graph in
    let roots = G.collect_df_roots df_only_graph in
    let leaves = G.collect_df_leaves df_only_graph in
    let carpro = roots >>= fun root -> leaves >>= fun leaf -> return (root, leaf) in
    (* not all leaves are reachable from all roots. So we filter out unreachable (root, leaf) pairs. *)
    let reachable_root_and_leaf_pairs =
      List.filter ~f:(fun (root, leaf) -> PathUtils.is_reachable root leaf df_only_graph) carpro
    in
    (* now, find the path between the root and the leaf. *)
    Array.concat
    @@ List.map
         ~f:(fun (root, leaf) ->
           PathUtils.find_paths_from_source_to_dest df_only_graph (G.LiteralVertex.of_vertex root)
             leaf )
         reachable_root_and_leaf_pairs


  let all_trunks = identify_trunks site_graph

  let _ = Array.length all_trunks (* 1776 *)

  let all_shortest_trunks = Trunk.identify_longest_trunks site_graph

  let _ = Array.length all_shortest_trunks (* 1252 *)

  (* 엄청나게 많이는 아니지만 꽤 줄긴 하네 *)

  let _ = End
end

module Notebook59 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let methods = Deserializer.deserialize_method_txt ()

  let graph_vertices = VertexMaker.get_all_vertices json

  let graph_methods = G.all_methods_of_graph df_edges_added

  let _ = End
end

module Notebook60 = struct
  (* Debugging Axioms *)

  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  (* mark_well_known_java_methods *)
  (* this_project_main_is_none *)
  (* internal_udf_vertex_is_none *)

  let test_mark_well_known_java_methods =
    (* 1. how many are well known java methods in this project? *)
    let sagan_well_known_java_methods =
      List.filter ~f:Method.is_well_known_java_none_method (G.all_methods_of_graph df_edges_added)
      (* length: 9 *)
    in
    (* 2. are they updated successfully? *)
    let sagan_well_known_java_method_vertices =
      sagan_well_known_java_methods >>= G.this_method_vertices df_edges_added
      (* length: 24 *)
    in
    ()


  (* Lesson (TODO): we have to add more to JavaExpert.none_methods! *)

  let test_this_project_main_is_none =
    (* 1. how many mains are there? *)
    let sagan_well_known_main_vertices =
      G.fold_vertex
        (fun vertex acc ->
          if Method.is_main_method (Vertex.to_string vertex) then vertex :: acc else acc )
        df_edges_added []
    in
    ()


  let test_internal_udf_vertex_is_none =
    (* 1. how many internal udfs are there? *)
    let sagan_udf_vertices =
      (* 1156 *)
      let time1 = Unix.time () in
      let out =
        G.fold_vertex
          (fun vertex acc -> if Method.is_udf (Vertex.get_method vertex) then vertex :: acc else acc)
          df_edges_added []
      in
      let time2 = Unix.time () in
      print_endline @@ F.asprintf "%f" (time2 -. time1) ;
      out
    in
    let sagan_internal_udf_vertices =
      let time1 = Unix.time () in
      let out =
        List.filter
          ~f:(fun vertex -> G.is_df_internal (G.LiteralVertex.of_vertex vertex) df_edges_added)
          sagan_udf_vertices
      in
      let time2 = Unix.time () in
      print_endline @@ F.asprintf "%f" (time2 -. time1) ;
      out
    in
    let sagan_internal_udf_vertices_no_annot =
      let time1 = Unix.time () in
      let out =
        List.filter
          ~f:(fun vertex ->
            let annot = vertex |> Vertex.get_method |> Annotations.get_annots in
            not @@ Annotations.equal annot Annotations.empty )
          sagan_internal_udf_vertices
      in
      let time2 = Unix.time () in
      print_endline @@ F.asprintf "%f" (time2 -. time1) ;
      out
    in
    ()


  let internal_udf_vertices_no_annot =
    let time1 = Unix.time () in
    let out =
      G.fold_vertex
        (fun vertex acc ->
          if
            Method.is_udf (Vertex.get_method vertex)
            && G.is_df_internal (G.LiteralVertex.of_vertex vertex) df_edges_added
            &&
            let annot = vertex |> Vertex.get_method |> Annotations.get_annots in
            Annotations.equal annot Annotations.empty
          then vertex :: acc
          else acc )
        df_edges_added []
    in
    let time2 = Unix.time () in
    print_endline @@ F.asprintf "%f" (time2 -. time1) ;
    out


  let _ = List.length @@ internal_udf_vertices_no_annot

  (* 왜 이거밖에 없지?? *)

  (* 14 seconds *)

  (* 오 쩐다 갑자기 최적화됐네 *)

  (* Lesson (TODO): short-circuiting 을 잘 활용하자. *)

  (* +) 나중에 visualization 해가면서 보자. *)

  let _ = End
end

module Notebook61 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let axiom_applied = Axioms.apply_axioms df_edges_added

  let _ =
    List.length
    @@ G.fold_vertex
         (fun vertex acc ->
           if ProbQuadruple.is_indeterminate (Vertex.get_dist vertex) then vertex :: acc else acc )
         axiom_applied []


  let _ =
    assert (
      Int.( = )
        (List.length @@ G.all_vertices_of_graph df_edges_added)
        (List.length @@ G.all_vertices_of_graph axiom_applied) )


  (* sanity check pass *)

  let unmarked_vertices =
    G.fold_vertex
      (fun vertex acc ->
        if ProbQuadruple.is_indeterminate (Vertex.get_dist vertex) then vertex :: acc else acc )
      axiom_applied []


  let marked_vertices =
    G.fold_vertex
      (fun vertex acc ->
        if not @@ ProbQuadruple.is_indeterminate (Vertex.get_dist vertex) then vertex :: acc
        else acc )
      axiom_applied []


  let all_methods = G.all_methods_of_graph df_edges_added

  let marked_methods = marked_vertices >>| Vertex.get_method |> List.stable_dedup (* 564 *)

  let unmarked_methods = unmarked_vertices >>| Vertex.get_method |> List.stable_dedup (* 316 *)

  let unmarked_udfs = List.filter ~f:Method.is_udf unmarked_methods

  let marked_udfs = List.filter ~f:Method.is_udf marked_methods

  let _ = List.length unmarked_udfs (* 188 *)

  let _ = List.length marked_udfs (* 334 *)

  let unmarked_udfs_without_annots =
    List.filter
      ~f:(fun meth -> not @@ Annotations.equal Annotations.empty (Annotations.get_annots meth))
      unmarked_udfs


  let _ = List.length unmarked_udfs_without_annots

  (* Curious: how many of unmarked_udfs are not annotated? *)

  let _ = List.length marked_udfs

  let _ = List.length unmarked_methods

  let _ = End
end

(* 그럼 일단 쪼개고, 각각의 쪼개진 그래프들에 대해서 위처럼 marked/unmarked를 나눠 주면 되는 것이다!!! *)

module Notebook65 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let axiom_applied = Axioms.apply_axioms df_edges_added

  let splitted = split_graph_by_comp_unit axiom_applied

  let renderer_graph = List.nth_exn splitted 0

  let site_graph = List.nth_exn splitted 1

  let renderer_graph_vertices = G.all_vertices_of_graph renderer_graph

  let renderer_unmarked_vertices =
    G.fold_vertex
      (fun vertex acc ->
        if ProbQuadruple.is_indeterminate (Vertex.get_dist vertex) then vertex :: acc else acc )
      renderer_graph []


  let renderer_unmarked_methods =
    renderer_unmarked_vertices >>| Vertex.get_method |> List.stable_dedup


  let renderer_unmarked_apis =
    renderer_unmarked_vertices >>| Vertex.get_method |> List.stable_dedup
    |> List.filter ~f:Method.is_api
    |> List.filter ~f:(not << Method.is_frontend)


  let renderer_unmarked_udfs =
    renderer_unmarked_vertices >>| Vertex.get_method |> List.stable_dedup
    |> List.filter ~f:Method.is_udf


  let _ = List.length renderer_graph_vertices (* 311 *)

  let _ = List.length renderer_unmarked_vertices (* 114 *)

  let _ = List.length renderer_unmarked_methods (* 51 *)

  (* finally, a managable size!! *)

  let site_graph_vertices = G.all_vertices_of_graph site_graph

  let site_unmarked_vertices =
    G.fold_vertex
      (fun vertex acc ->
        if ProbQuadruple.is_indeterminate (Vertex.get_dist vertex) then vertex :: acc else acc )
      site_graph []


  let site_unmarked_methods = site_unmarked_vertices >>| Vertex.get_method |> List.stable_dedup

  let _ = List.length site_graph_vertices (* 1645 *)

  let _ = List.length site_unmarked_vertices (* 684 *)

  let _ = List.length site_unmarked_methods (* 280 *)

  (* break it down a bit more *)

  let site_unmarked_apis =
    site_unmarked_vertices >>| Vertex.get_method |> List.stable_dedup
    |> List.filter ~f:Method.is_api
    |> List.filter ~f:(not << Method.is_frontend)


  let site_unmarked_udfs =
    site_unmarked_vertices >>| Vertex.get_method |> List.stable_dedup
    |> List.filter ~f:Method.is_udf


  let _ = List.length site_unmarked_apis (* 97 *)

  let _ = List.length site_unmarked_udfs (* 162 *)

  (* OK, much more managable. *)

  let _ = End
end

module Notebook66 = struct
  let method_ = "Post PostRepository.findByPublicSlugAndDraftFalseAndPublishAtBefore(String,Date)"

  let other_method_with_same_classname =
    List.find_exn
      ~f:(fun other_method ->
        String.equal (Method.get_class_name method_) (Method.UniqueID.get_class_name other_method)
        )
      (Deserializer.deserialize_skip_func () @ Deserializer.deserialize_method_txt ())


  let _ = Method.get_package_name method_

  let get_package_name (method_ : Method.t) : string =
    try
      let unique_id = find_unique_identifier method_ in
      UniqueID.get_package_name unique_id
    with Core_kernel.Not_found_s _ ->
      let other_method_with_same_classname =
        List.find_exn
          ~f:(fun other_method ->
            String.equal (get_class_name method_) (UniqueID.get_class_name other_method) )
          (Deserializer.deserialize_skip_func () @ Deserializer.deserialize_method_txt ())
      in
      UniqueID.get_package_name other_method_with_same_classname


  let _ = get_package_name method_

  let _ = End
end

module Notebook67 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let all_udfs = df_edges_added |> G.all_methods_of_graph |> List.filter ~f:Method.is_udf

  let all_apis =
    df_edges_added |> G.all_methods_of_graph |> List.filter ~f:Method.is_api
    |> List.filter ~f:(not << Method.is_dunder)


  let _ = List.length all_udfs

  let _ = List.length all_apis

  let all_methods = G.all_methods_of_graph df_edges_added

  let _ = List.length all_methods

  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let renderer_udfs = renderer_graph |> G.all_methods_of_graph |> List.filter ~f:Method.is_udf

  let renderer_apis =
    renderer_graph |> G.all_methods_of_graph |> List.filter ~f:Method.is_api
    |> List.filter ~f:(not << Method.is_dunder)


  let site_graph = List.nth_exn splitted 1

  let site_udfs = site_graph |> G.all_methods_of_graph |> List.filter ~f:Method.is_udf

  let site_apis =
    site_graph |> G.all_methods_of_graph |> List.filter ~f:Method.is_api
    |> List.filter ~f:(not << Method.is_dunder)


  let _ = End
end

module Notebook68 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let site_graph = List.nth_exn splitted 1

  let renderer_trunks = identify_longest_trunks renderer_graph

  let site_trunks = identify_longest_trunks site_graph

  let _ = Trunk.Serializer.serialize_graph_trunks_to_json renderer_graph

  let _ = Trunk.Serializer.serialize_graph_trunks_to_json site_graph

  let _ = End
end

module Notebook69 = struct
  let _ = spawn_python ~pyfile:"./python/compute_nodewise_similarity.py" ~args:[]

  let csv_filename = "NodeWiseFeatures_sagan-renderer_udfs.csv_filtered.csv"

  let ns_table_from_csv csv_filename =
    let acc = Hashtbl.create 777 in
    let in_chan = In_channel.create csv_filename in
    let csv_array = Csv.to_array @@ Csv.load_in in_chan in
    In_channel.close in_chan ;
    for i = 1 to Array.length csv_array - 1 do
      let method1 = csv_array.(i).(1)
      and method2 = csv_array.(i).(12)
      and ns_score = int_of_string @@ csv_array.(i).(23) in
      Hashtbl.add acc (method1, method2) ns_score
    done ;
    acc


  let read =
    let in_chan = In_channel.create csv_filename in
    let out = Csv.to_array @@ Csv.load_in in_chan in
    In_channel.close in_chan ;
    out


  let ns_table = ns_table_from_csv "NodeWiseFeatures_sagan-renderer_udfs.csv_filtered.csv"

  let _ = End
end

module Notebook70 = struct
  exception End

  let csv_filename =
    "/Users/jslee/Dropbox/InferenceEngine/lib/sagan-renderer_all_longest_trunks.json_filtered.csv"


  let cs_table_from_csv csv_filename =
    let acc = Hashtbl.create 777 in
    let in_chan = In_channel.create csv_filename in
    List.iter ~f:(fun array -> raise TODO) (Csv.load_in in_chan) ;
    In_channel.close in_chan ;
    acc


  let read =
    let in_chan = In_channel.create csv_filename in
    let out = Csv.to_array @@ Csv.load_in in_chan in
    In_channel.close in_chan ;
    out


  let _ = End
end

module Notebook71 = struct
  let _ =
    DirectoryManager.get_compilation_unit_subdirs
      "/Users/jslee/Taint-Analysis/Code/benchmarks/realworld/relational-data-access"


  (* this is not the problem *)

  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let _ = G.all_methods_of_graph df_edges_added

  let _ = split_graph_by_comp_unit df_edges_added

  let _ = get_comp_unit "int[] JdbcTemplate.batchUpdate(String,List)"

  let _ = Trunk.identify_longest_trunks df_edges_added

  let _ = Trunk.Serializer.all_longest_trunks_to_json df_edges_added

  let _ = Trunk.Serializer.serialize_graph_trunks_to_json df_edges_added

  let _ = End
end

module Notebook72 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let _ = G.all_methods_of_graph df_edges_added

  let graph = List.hd_exn @@ split_graph_by_comp_unit df_edges_added

  let unmarked_apis = G.get_unmarked_apis graph

  let unmarked_udfs = G.get_unmarked_udfs graph

  open NodeWiseFeatures.NodeWiseFeatureMap

  let api_map, udf_map = init_for_graph graph

  let _ =
    CSVSerializer.serialize api_map
      ~filename:(F.asprintf "NodeWiseFeatures_%s_apis.csv" graph.comp_unit)


  let _ =
    CSVSerializer.serialize udf_map
      ~filename:(F.asprintf "NodeWiseFeatures_%s_udfs.csv" graph.comp_unit)


  let _ = G.get_unmarked_udfs graph

  let _ = End
end

module Notebook73 = struct
  (* debugging Propagation *)

  (* first and foremost, we initialize the graph *)

  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let relational =
    {df_edges_added with comp_unit= "src"}
    |> SimilarityHandler.make_nodewise_sim_edge |> SimilarityHandler.make_contextual_sim_edge


  let _ = Visualizer.visualize_snapshot relational ~micro:false ~autoopen:true

  let _ = Loop.loop relational NodeWiseFeatureMap.empty

  let _ = End
end

module Notebook74 = struct
  (* debugging SimilarityHandler.make_nodewise_sim_edge *)

  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let df_edges_added = List.hd_exn splitted

  let ns_edges_added = SimilarityHandler.make_nodewise_sim_edge df_edges_added

  let _ = Visualizer.visualize_snapshot ns_edges_added ~autoopen:true ~micro:false

  (* ============ debugging ============ *)

  let graph = ns_edges_added

  let udf_csv_filename = F.asprintf "NodeWiseFeatures_%s_udfs.csv_filtered.csv" graph.comp_unit

  and api_csv_filename = F.asprintf "NodeWiseFeatures_%s_apis.csv_filtered.csv" graph.comp_unit

  let udf_in_chan = In_channel.create udf_csv_filename

  and api_in_chan = In_channel.create api_csv_filename

  let csv_array =
    let udf_array = Array.slice (Csv.to_array @@ Csv.load_in udf_in_chan) 1 0
    and api_array = Array.slice (Csv.to_array @@ Csv.load_in api_in_chan) 1 0 in
    Array.append udf_array api_array


  let _ =
    In_channel.close udf_in_chan ;
    In_channel.close api_in_chan


  let acc = ref graph

  let _ =
    for i = 0 to Array.length csv_array - 1 do
      let method1 = csv_array.(i).(1) and method2 = csv_array.(i).(12) in
      print_endline method1 ;
      print_endline method2 ;
      let m1_vertices = G.this_method_vertices df_edges_added method1
      and m2_vertices = G.this_method_vertices df_edges_added method2 in
      List.iter
        ~f:(fun m1_vertex ->
          List.iter
            ~f:(fun m2_vertex ->
              acc := G.add_edge_e !acc (m1_vertex, EdgeLabel.NodeWiseSimilarity, m2_vertex) )
            m2_vertices )
        m1_vertices
    done


  let _ = !acc

  let _ = Visualizer.visualize_snapshot !acc ~autoopen:true ~micro:false

  let _ = End
end

module Notebook75 = struct
  (* debugging SimilarityHandler.make_contextual_sim_edge *)

  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let df_edges_added = List.hd_exn splitted

  let ns_edges_added = SimilarityHandler.make_nodewise_sim_edge df_edges_added

  (* ============ debugging ============ *)

  let graph = ns_edges_added

  let csv_filename = F.asprintf "%s_all_longest_trunks.json_filtered.csv" graph.comp_unit

  let in_chan = In_channel.create csv_filename

  let csv_array = Csv.to_array @@ Csv.load_in in_chan

  let _ = In_channel.close in_chan

  let acc = ref graph

  let _ =
    for i = 1 to Array.length csv_array - 1 do
      let vertex1 = csv_array.(i).(1) and vertex2 = csv_array.(i).(2) in
      let vertex1 = G.LiteralVertex.to_vertex (G.LiteralVertex.of_string vertex1) !acc.graph
      and vertex2 = G.LiteralVertex.to_vertex (G.LiteralVertex.of_string vertex2) !acc.graph in
      acc := G.add_edge_e !acc (vertex1, EdgeLabel.ContextualSimilarity, vertex2)
    done


  let _ = !acc

  (* ============ debugging end ============ *)

  let _ = Visualizer.visualize_snapshot !acc ~autoopen:true ~micro:false

  let _ = End
end

module Notebook76 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  (* ============ renderer ============ *)
  let renderer_graph = List.nth_exn splitted 0

  let axiom_applied = Axioms.apply_axioms renderer_graph

  let _ = Trunk.Serializer.serialize_graph_trunks_to_json axiom_applied

  let _ = End
end

module Notebook77 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  (* ============ renderer ============ *)
  let renderer_graph = List.nth_exn splitted 0

  let renderer_finished = Main.build_graph renderer_graph

  let ns_clusters = all_ns_clusters renderer_finished

  let _ = End
end

module Notebook78 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let renderer_finished = SimilarityHandler.make_nodewise_sim_edge renderer_graph

  let graph = renderer_graph

  let udf_csv_filename = F.asprintf "NodeWiseFeatures_%s_udfs.csv_filtered.csv" graph.comp_unit

  and api_csv_filename = F.asprintf "NodeWiseFeatures_%s_apis.csv_filtered.csv" graph.comp_unit

  let udf_in_chan = In_channel.create udf_csv_filename

  and api_in_chan = In_channel.create api_csv_filename

  let csv_array =
    let udf_array = Array.slice (Csv.to_array @@ Csv.load_in udf_in_chan) 1 0
    and api_array = Array.slice (Csv.to_array @@ Csv.load_in api_in_chan) 1 0 in
    Array.append udf_array api_array


  let _ = In_channel.close udf_in_chan

  let _ = In_channel.close api_in_chan

  let _ = Out_channel.print_string "Now adding NS edges..."

  let _ = Out_channel.flush stdout

  let acc = ref graph

  let _ =
    for i = 0 to Array.length csv_array - 1 do
      (* let method1 = csv_array.(i).(1) and method2 = csv_array.(i).(12) in *)
      let method1 = csv_array.(i).(1) and method2 = csv_array.(i).(2) in
      let m1_vertices = G.this_method_vertices graph method1
      and m2_vertices = G.this_method_vertices graph method2 in
      List.iter
        ~f:(fun m1_vertex ->
          List.iter
            ~f:(fun m2_vertex ->
              acc := G.add_edge_e !acc (m1_vertex, EdgeLabel.NodeWiseSimilarity, m2_vertex) )
            m2_vertices )
        m1_vertices
    done


  let _ = Out_channel.print_endline "done"

  let _ = !acc

  let _ = End
end

module Notebook79 = struct
  (* profiling Loop.loop *)

  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let renderer_finished = Main.build_graph renderer_graph

  let current_snapshot = renderer_finished

  let nodewise_featuremap = NodeWiseFeatureMap.empty

  let received_responses = []

  let question_maker =
    MetaRules.ForAsking.asking_rules_selector current_snapshot received_responses
      nodewise_featuremap


  open MetaRules.ForAsking

  let graph = current_snapshot

  let responses = received_responses

  let nfeaturemap = nodewise_featuremap

  let priority_assigned =
    assign_priority_on_asking_rules
      (take_subset_of_applicable_asking_rules graph responses nfeaturemap AskingRules.all_rules)
      graph


  let _ = take_subset_of_applicable_asking_rules graph responses nfeaturemap AskingRules.all_rules

  open AskingRules

  let all_rules : t array =
    [| {label= "ask_if_leaf_is_sink"; rule= ask_if_leaf_is_sink}
     ; {label= "ask_if_root_is_source"; rule= ask_if_root_is_source}
     ; {label= "ask_foreign_package_label"; rule= ask_foreign_package_label}
     ; {label= "ask_indeterminate"; rule= ask_indeterminate}
     ; { label= "ask_from_ns_cluster_if_it_contains_internal_src_or_sink"
       ; rule= ask_from_ns_cluster_if_it_contains_internal_src_or_sink } |]


  let snapshot = current_snapshot

  let _ = ask_if_leaf_is_sink snapshot received_responses nfeaturemap

  let _ = End
end

(* all_ns_clusters was the culprit!!!
   also, it's being used at lots of places in
   RulesOfInference.ml. *)

module Notebook80 = struct
  exception End

  let graph_comp_unit = "sagan-renderer"

  type json = Yojson.Basic.t

  module Json = Yojson.Basic

  (* ============ *)

  let udf_json_filename = F.asprintf "NodeWiseFeatures_%s_udfs.csv_filtered.json" graph_comp_unit

  and api_json_filename = F.asprintf "NodeWiseFeatures_%s_apis.csv_filtered.json" graph_comp_unit

  let parse_mst_json filename =
    let udf_json =
      let in_chan = In_channel.create udf_json_filename in
      let json = Json.from_channel in_chan in
      In_channel.close in_chan ;
      json
    in
    Util.to_list udf_json
    >>| fun lst -> Util.to_list lst >>| fun l -> Util.to_list l |> Util.filter_string


  let udf_parsed = parse_mst_json udf_json_filename

  let api_parsed = parse_mst_json api_json_filename

  let _ = udf_parsed >>| fun tuplist -> tuplist >>= ident |> List.stable_dedup

  (* ============ *)

  let _ = End
end

module Notebook81 = struct
  exception End

  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let renderer_finished = Main.build_graph renderer_graph

  let ns_edges = G.get_edges ~label:EdgeLabel.NodeWiseSimilarity renderer_finished

  let graph = renderer_graph

  let udf_csv_filename = F.asprintf "NodeWiseFeatures_%s_udfs.csv_filtered.csv" graph.comp_unit

  and api_csv_filename = F.asprintf "NodeWiseFeatures_%s_apis.csv_filtered.csv" graph.comp_unit

  let udf_in_chan = In_channel.create udf_csv_filename

  and api_in_chan = In_channel.create api_csv_filename

  let csv_array =
    let udf_array = Csv.to_array @@ Csv.load_in udf_in_chan
    and api_array = Csv.to_array @@ Csv.load_in api_in_chan in
    Array.append udf_array api_array


  let acc = ref graph

  let sample_row = csv_array.(3)

  let _ =
    for i = 0 to Array.length csv_array - 1 do
      (* let method1 = csv_array.(i).(1) and method2 = csv_array.(i).(12) in *)
      let method1 = csv_array.(i).(0) and method2 = csv_array.(i).(1) in
      let m1_vertices = G.this_method_vertices graph method1
      and m2_vertices = G.this_method_vertices graph method2 in
      List.iter
        ~f:(fun m1_vertex ->
          List.iter
            ~f:(fun m2_vertex ->
              acc := G.add_edge_e !acc (m1_vertex, EdgeLabel.NodeWiseSimilarity, m2_vertex) ;
              acc := G.add_edge_e !acc (m2_vertex, EdgeLabel.NodeWiseSimilarity, m1_vertex) )
            m2_vertices )
        m1_vertices
    done


  let _ = G.equal !acc graph

  let _ = End
end

module Notebook82 = struct
  exception End

  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let renderer_finished = Main.build_graph renderer_graph

  let _ = Visualizer.visualize_snapshot renderer_graph ~autoopen:true ~micro:false

  let _ = Visualizer.visualize_snapshot renderer_finished ~autoopen:true ~micro:false
  (* taking too much! *)

  let _ = End
end

module Notebook83 = struct
  exception End

  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let df_leaves = G.collect_df_leaves renderer_graph

  let _ = Visualizer.visualize_snapshot renderer_graph ~autoopen:true ~micro:false

  (* JavaExpert에 있지 않고, rtntype이 void가 아니라면 dead slice를 없애지 말 것 *)

  let _ = End
end

module Notebook84 = struct
  exception End

  let mini_json =
    let in_channel = In_channel.create "test-chain.json" in
    let out = Json.from_channel in_channel in
    In_channel.close in_channel ;
    out


  let mini_graph = G.empty |> batch_add_vertex mini_json |> batch_add_edge mini_json

  let _ = Visualizer.visualize_snapshot mini_graph ~micro:false ~autoopen:true

  let _ = EdgeMaker.get_all_edges_and_frontend_defines mini_json

  let edge_list_and_frontend_define_vertex_opt_list =
    wrapped_chain_list_of_raw_json mini_json
    >>| chain_slice_list_of_wrapped_chain >>= EdgeMaker.edge_list_of_chain_slice_list


  let chain_slices =
    List.hd_exn @@ (wrapped_chain_list_of_raw_json mini_json >>| chain_slice_list_of_wrapped_chain)


  let _ = End
end

module Notebook85 = struct
  exception End

  let mini_json =
    let in_channel = In_channel.create "test-chain2.json" in
    let out = Json.from_channel in_channel in
    In_channel.close in_channel ;
    out


  let mini_graph = G.empty |> batch_add_vertex mini_json |> batch_add_edge mini_json

  let _ = Visualizer.visualize_snapshot mini_graph ~micro:false ~autoopen:true

  let _ = EdgeMaker.get_all_edges_and_frontend_defines mini_json

  let edge_list_and_frontend_define_vertex_opt_list =
    wrapped_chain_list_of_raw_json mini_json
    >>| chain_slice_list_of_wrapped_chain >>= EdgeMaker.edge_list_of_chain_slice_list


  let chain_slices =
    List.hd_exn @@ (wrapped_chain_list_of_raw_json mini_json >>| chain_slice_list_of_wrapped_chain)


  let _ = End
end

module Notebook86 = struct
  exception End

  (* snapshot to json repr *)

  (*
   json sketch:

   {
     "(f1, { line 3 })": "label1",
     "(f2, { line 5})" : "label2"
   }
   *)

  let mini_json =
    let in_channel = In_channel.create "test-chain2.json" in
    let out = Json.from_channel in_channel in
    In_channel.close in_channel ;
    out


  let mini_graph = G.empty |> batch_add_vertex mini_json |> batch_add_edge mini_json

  let snapshot_to_json (snapshot : G.t) : unit =
    let vertices = G.all_vertices_of_graph snapshot in
    let vertices_and_labels =
      List.map
        ~f:(fun vertex ->
          let label = ProbQuadruple.determine_label (Vertex.get_dist vertex) in
          (vertex, label) )
        vertices
    in
    let vertex_strs_and_label_strs =
      List.map
        ~f:(fun (vertex, label) -> (Vertex.to_string vertex, TaintLabel.to_string_short label))
        vertices_and_labels
    in
    let json_repr =
      `Assoc
        (List.map
           ~f:(fun (vertex_str, label_str) -> (vertex_str, `String label_str))
           vertex_strs_and_label_strs )
    in
    let json_filename = F.asprintf "%s_labels.json" @@ make_now_string 9 in
    let out_channel = Out_channel.create json_filename in
    pretty_to_channel out_channel json_repr ;
    Out_channel.close out_channel


  let _ = snapshot_to_json mini_graph

  let _ = End
end

module Notebook87 = struct
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let renderer_finished = Main.build_graph renderer_graph

  let this_fragment_unmarked_apis = G.get_unmarked_apis renderer_graph

  and this_fragment_unmarked_udfs = G.get_unmarked_udfs renderer_graph

  open NodeWiseFeatures.NodeWiseFeatureMap

  let this_fragment_unmarked_apis_featuremap, this_fragment_unmarked_udfs_featuremap =
    init_for_graph renderer_graph


  let nfeaturemap =
    merge_two_maps this_fragment_unmarked_udfs_featuremap this_fragment_unmarked_apis_featuremap


  let _ = Loop.loop renderer_finished nfeaturemap

  (* eh... we need to profile Loop.loop_inner. *)

  let current_snapshot = renderer_finished

  let nodewise_featuremap = nfeaturemap

  let count = 0

  let received_responses =
    [Response.ForLabel ("void RendererApplication.main(String[]", TaintLabel.None)]


  let input = Some "non"

  let _ =
    if G.Saturation.all_dists_in_graph_are_saturated current_snapshot then current_snapshot
    else
      (* find the most appropriate Asking Rule. *)
      let question_maker =
        MetaRules.ForAsking.asking_rules_selector current_snapshot received_responses
          nodewise_featuremap
      in
      let question = question_maker.rule current_snapshot received_responses nodewise_featuremap in
      let prompt = Question.make_prompt question in
      Out_channel.output_string Out_channel.stdout prompt ;
      Out_channel.flush Out_channel.stdout ;
      if Option.is_none input || String.equal (Option.value_exn input) "stop" then current_snapshot
      else
        let response =
          match input with
          | Some response_str -> (
            match question with
            | AskingForLabel meth ->
                Response.response_of_string_forlabel meth response_str
            | AskingForConfirmation (meth, label) ->
                Response.response_of_string_foryesorno meth label response_str )
          | None ->
              failwith "no response ahahahah"
        in
        (* sort applicable Propagation Rules by adequacy. *)
        let propagation_rules_to_apply =
          MetaRules.ForPropagation.sort_propagation_rules_by_priority current_snapshot response
            received_responses
        in
        (* propagator was the culprit. *)
        let propagated =
          List.fold
            ~f:(fun acc prop_rule ->
              fst
              @@ propagator response acc None propagation_rules_to_apply received_responses []
                   PropagationRules.all_rules )
            ~init:current_snapshot propagation_rules_to_apply
        in
        let propagated' = Axioms.apply_axioms propagated in
        Visualizer.visualize_snapshot propagated' ~micro:false ~autoopen:true ;
        G.serialize_to_bin propagated' ;
        G.snapshot_to_json propagated' ;
        loop_inner propagated' (response :: received_responses) nodewise_featuremap (count + 1)


  let _ = End
end

module Notebook88 = struct
  (* profiling propagator *)
  let df_edges_added =
    match graph_already_serialized ~comp_unit:"" ~suffix:"df_edges" with
    | None ->
        let result = G.empty |> batch_add_vertex json |> batch_add_edge json in
        G.serialize_to_bin result ~suffix:"df_edges" ;
        result
    | Some filename ->
        Deserializer.deserialize_graph filename


  let splitted = split_graph_by_comp_unit df_edges_added

  let renderer_graph = List.nth_exn splitted 0

  let renderer_finished = Main.build_graph renderer_graph

  let response =
    Response.ForLabel
      ("void RendererApplication.main(String[])", InferenceEngineLib.GraphRepr.TaintLabel.None)


  let received_responses =
    [ InferenceEngineLib.RulesOfInference.Response.ForLabel
        ("void RendererApplication.main(String[]", InferenceEngineLib.GraphRepr.TaintLabel.None) ]


  open RulesOfInference.PropagationRules

  let propagation_rules_to_apply =
    [ {rule= contextual_similarity_rule; label= "contextual_similarity_rule"}
    ; { rule= internal_nonbidirectional_library_node_is_a_src_if_leaf_is_sink
      ; label= "internal_nonbidirectional_library_node_is_a_src_if_leaf_is_sink" }
    ; { rule= if_method_is_none_once_then_it's_none_everywhere
      ; label= "if_method_is_none_once_then_it's_none_everywhere" } ]


  let current_snapshot = renderer_finished

  let acc = current_snapshot

  (* response
     acc
     None
     propagation_rules_to_apply
     received_responses
     []
     PropagationRules.all_rules *)

  (* (new_fact : Response.t)
     (current_snapshot : G.t)
     (previous_snapshot : G.t option)
     (rules_to_propagate : PropagationRules.t list)
     (prev_facts : Response.t list)
     (history : Vertex.t list)
     (prop_rule_pool : PropagationRules.t list) *)

  let new_fact = response

  let current_snapshot = acc

  let previous_snapshot = None

  let rules_to_propagate = propagation_rules_to_apply

  let prev_facts = received_responses

  let history = []

  let prop_rule_pool = PropagationRules.all_rules

  let propagator =
    if List.is_empty rules_to_propagate then
      (* if we can't propagate any further, terminate *)
      (current_snapshot, [])
    else if
      List.mem (history >>| Vertex.get_method) (Response.get_method new_fact) ~equal:Method.equal
    then (current_snapshot, history)
    else (
      Out_channel.print_endline "==============================" ;
      Out_channel.print_endline
        (F.asprintf "propagator is propagating on %s" (Response.to_string new_fact)) ;
      let current_visiting_vertices =
        G.this_method_vertices current_snapshot (Response.get_method new_fact)
      in
      Out_channel.print_endline
      @@ F.asprintf "current_visiting_vertices: %s"
           (Vertex.vertex_list_to_string current_visiting_vertices) ;
      (* do the propagation *)
      let propagated_snapshot, current_propagation_targets =
        List.fold
          ~f:(fun (snapshot_acc, affected_vertices) (rule : PropagationRules.t) ->
            let propagated, this_affected =
              let out = rule.rule snapshot_acc new_fact prev_facts ~dry_run:false in
              Visualizer.visualize_snapshot (fst out) ~micro:true ~autoopen:false ;
              out
            in
            (propagated, affected_vertices @ this_affected) )
          ~init:(current_snapshot, []) rules_to_propagate
      in
      let out =
        List.fold
          ~f:(fun (big_acc, big_history) target ->
            if
              List.mem big_history target ~equal:Vertex.equal
              || List.mem ~equal:Vertex.equal current_visiting_vertices target
            then (big_acc, big_history)
            else (
              Out_channel.print_endline
              @@ F.asprintf "\npropagator is iterating on %s" (Vertex.to_string target) ;
              if
                List.mem big_history target ~equal:Vertex.equal
                || List.mem ~equal:Vertex.equal current_visiting_vertices target
              then (big_acc, big_history)
              else
                let target_meth, target_loc, target_dist = target in
                (* summarize this node's distribution into a Response.t! *)
                let target_rule_summary =
                  Response.response_of_dist (fst3 target)
                    (G.lookup_dist_for_meth_and_loc target_meth target_loc propagated_snapshot)
                in
                (* Out_channel.print_endline *)
                (* @@ F.asprintf "\ntarget_rule_summary of %s: %s, dist: %s\n" (fst3 target) *)
                (*      (Response.to_string target_rule_summary) *)
                (*      (ProbQuadruple.to_string *)
                (*         (G.lookup_dist_for_meth_and_loc target_meth target_loc propagated_snapshot) ) ; *)
                let applicable_rules =
                  MetaRules.ForPropagation.take_subset_of_applicable_propagation_rules
                    current_snapshot target_rule_summary prev_facts prop_rule_pool
                in
                let propagated, updated_history =
                  List.fold
                    ~f:(fun (smol_acc, smol_history) prop_rule ->
                      let out =
                        propagator target_rule_summary smol_acc (Some current_snapshot)
                          applicable_rules
                          (target_rule_summary :: new_fact :: prev_facts)
                          smol_history prop_rule_pool
                      in
                      out )
                    ~init:(big_acc, big_history) applicable_rules
                in
                if Option.is_some previous_snapshot then
                  G.print_snapshot_diff (Option.value_exn previous_snapshot) propagated ;
                (propagated, updated_history) ) )
          ~init:(propagated_snapshot, current_visiting_vertices @ history)
          current_propagation_targets
      in
      out )


  open NodeWiseFeatureMap

  let this_fragment_unmarked_apis_featuremap, this_fragment_unmarked_udfs_featuremap =
    init_for_graph renderer_graph


  let nfeaturemap =
    merge_two_maps this_fragment_unmarked_udfs_featuremap this_fragment_unmarked_apis_featuremap

  let _ = Loop.loop renderer_finished nfeaturemap

  let _ = End
end

module Notebook89 = struct
  let _ = End
end
